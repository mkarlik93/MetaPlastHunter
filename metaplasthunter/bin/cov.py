#!/usr/bin/env python

###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = 'Michal Karlicki'
__copyright__ = 'Copyright 2018'
__credits__ = ['Michal Karlicki']
__license__ = 'GPL3'
__version__ = '1.0.0'
__maintainer__ = 'Michal Karlicki'
__email__ = 'michal.karlicki@gmail.com'
__status__ = 'Development'

from settings import  Settings_loader_yaml
from Bio import SeqIO
from subprocess import Popen, PIPE
import numpy as np
import sys
import logging
import os

logger = logging.getLogger("src.cov")
logging.basicConfig(level=logging.INFO)

class Coverage:

    def __init__(self,filename, histstats,settings):

        """
        Parameters
        ----------
        name : filename
            bincov.txt, draft coverage file, produced during mapping
        sound : histstats
            XXX
        num_legs : settings
            General settings file which keeps hyperparameters

        Calculated gobal variables
        ----------
        min_bin_coverage: int
            Loaded from settings file
        percentile_threshold: int

        bin_cov_for_report: int

        static_threshold: int

        """

        self.loaded_bin_cov = self.load_bincov(filename)
        self.database = Settings_loader_yaml(settings).yaml_handler()["Databases and mapping files"]["bbmap_base"]
        self.min_bin_coverage = Settings_loader_yaml(settings).yaml_handler()["Params"]["min_bin_coverage"]
        self.percentile_threshold = Settings_loader_yaml(settings).yaml_handler()["Params"]["percentile_threshold"]
        self.bin_cov_for_report =  Settings_loader_yaml(settings).yaml_handler()["Params"]["bincov4_report"]
        self.static_threshold = Settings_loader_yaml(settings).yaml_handler()["Params"]["static_coverage_threshold[%]"]

    def load_bincov(self, filename):

        """ Load bincov file generated by Pileup """

        with open(filename,"r") as f:
            organisms = {}
            for i in f:
                splited = i.split("\t")
                if splited[0] not in organisms and splited[0][0] != "#":
                    organisms[splited[0]] = [float(splited[1])]
                else:
                    if splited[0][0] != "#":
                        organisms[splited[0]].append(float(splited[1]))
        return organisms

    def average_coverage(self):

        """ Calculates average depth of coverage """

        bin_cov_dict = self.loaded_bin_cov
        dict_of_genomes = {}
        for reference_genome in bin_cov_dict:
            dict_of_genomes[reference_genome] = np.mean(bin_cov_dict[reference_genome])
        return dict_of_genomes


    def getpercentage_cov(self):

        """ Calculates absolute coverage  """

        percentile_thresh = self.percentile_threshold

        dict_gen_con = {}
        dict_bin_cov = self.loaded_bin_cov

        for i in dict_bin_cov:

            name = i
            record = dict_bin_cov[i]
            mean = np.mean(record)
            median = np.quantile(record, 0.5)
            if mean > 0:
                all_seq = len(record)
#                list_tmp = [i for i,v in enumerate(record) if v >  self.min_bin_coverage]
                list_tmp = [i for i, v in enumerate(record) if v > median]
                covered_part = len(list_tmp)/float(all_seq) * 100
                dict_gen_con[covered_part] = name

        percentages = sorted(dict_gen_con.keys())

        if len(percentages) == 0:
            logger.error("There was no pre classified plastids")
            sys.exit()

        sum_percentages = sum(percentages)
        percentile_value =  np.percentile(percentages,percentile_thresh)
        percentages_ok = [i for i in percentages if i > percentile_value]

        """ static filtration """
        percentages_ready = [i for i in percentages if i > self.static_threshold]
        percentages_values_discared = [i for i in percentages if i < percentile_value]

        list_for_recalculation = []

        with open("cov_list.txt","w") as f:

            for key in percentages_ready:

                list_for_recalculation.append(dict_gen_con[key])

                f.write("%s,%s\n" % (dict_gen_con[key], key))

        return list_for_recalculation

    def report_cov(self):

        """ Reports fully/partially covered reference genomes """

#        threshold = self.bin_cov_for_report
        dict_of_genomes = {}
        dict_loaded_bin_cov = self.loaded_bin_cov
        for i in dict_loaded_bin_cov:
            name = i
            record = dict_loaded_bin_cov[i]
            mean = np.mean(record)
            if mean > 0:
                all_seq = len(record)
                list_tmp = [i for i, v in enumerate(record) if v > self.bin_cov_for_report]
                covered_part = len(list_tmp)/float(all_seq)

                if covered_part > 0.5:
                    if i is not 0:
                        dict_of_genomes[name] = str((covered_part*100.0))
                else:
                    pass

        if len(dict_of_genomes) == 0:

            logger.info("There is no fully/partially covered genomes")

        else:

            with open("covered_genomes.csv", 'w') as f:
                f.write("Genome name and id\tcoverage[%]\n")
                for key in dict_of_genomes:
                    f.write("%s\t%s\n" % (key, dict_of_genomes[key]))
                    logger.info("Genome of %s is almost fully covered" % key)

class Coverage_utilities:

    """

    This class generates empirical threshold for every genome in the reference database

            Parameters
            ----------
            name : str
                bincov.txt, draft coverage file, produced during mapping
            sound : histstats
                XXX

            num_legs : settings
                General settings file which keeps hyperparameters

            Calculated gobal variables
            ----------
            min_bin_coverage: int
                Loaded from settings file

            bin_cov_for_report: int

            static_threshold: int

    """

    def __init__(self, settings):

        self.settings = settings
        self.database = Settings_loader_yaml(settings).yaml_handler()["Databases and mapping files"]["bbmap_base"]
        self.path = Settings_loader_yaml(path=self.settings).yaml_handler()["Software dependencies"]["randomreads.sh"]
        self.e_coverage_threshold = Settings_loader_yaml(settings).yaml_handler()["Databases and mapping files"]["empirical_threshold"]
        if self.e_coverage_threshold is not None:
            self.e_coverage_threshold_dictionary = self.load_emprirical_coverage()

    def load_emprirical_coverage(self):

        """ Load reference genome empricial thresholds """

        with open(self.e_coverage_threshold, "r") as f:
            return dict([genome.split("\t") for genome in f])

    def analyze_emp_genome_list(self):

        """ Checking genomes without annotation """

        genome_list = [seq for seq in (SeqIO.parse(self.database,"fasta"))]
        empirical_keys = self.e_coverage_threshold_ditionary.keys()
        return  list(filter(lambda x: x.id not in empirical_keys, genome_list))

    def create_reads(self, genome_to_analyze):

        """ Random reads generator of length 100

        and insert size between 100 - 300 """

        logger.info("     Read creating ")
        command="%srandomreads.sh ref=%s.fa coverage=2 paired=t out1=%s_1.fq out2=%s_2.fq" % (self.path, genome_to_analyze,genome_to_analyze,genome_to_analyze)
        command = command.split(" ")
        process = Popen(command, stdout=PIPE, stderr=PIPE)
        stdout, stderr = process.communicate()
        return "DECOMPLEXATION"+"\n"+stderr

    #change it to static method
    def cleaning(self, project_name):

        """ Removing temporary data """

        command = "rm -r %s" % project_name
        command_2 = "rm %s_1.fq %s_2.fq" % (project_name, project_name)
        command_3 = "rm %s.fa" % project_name
        os.system(command)
        os.system(command_2)
        os.system(command_3)

    def run_MetaPlastHunter(self, genome_to_analyze):

        """ Wrapper of MetaPlastHunter """

        logger.info("   Creating artificial reads" )
        self.create_reads(genome_to_analyze)
        logger.info("   Estimating coverage threshold" )
        command="MetaPlastHunter --in_1 %s_1.fq --in_2 %s_2.fq -C --output %s --settings %s"  % (genome_to_analyze,genome_to_analyze,genome_to_analyze,self.settings)
        command = command.split(" ")
        process = Popen(command, stdout=PIPE, stderr=PIPE)
        stdout, stderr = process.communicate()

        old_dir = os.getcwd()
        os.chdir(old_dir+"/"+genome_to_analyze+"/")

        with open("covered_genomes.csv", "r") as f:
            threshold = float([genome.split("\t") for genome in f][1][1])

        os.chdir(old_dir)
        self.cleaning(genome_to_analyze)
        return threshold

    def add_empirical_threshold(self):

        """ In this fuction run_MetaPlastHunter is called for every reference genome that

         hasn't had already calculated empirical threshold  """

        if self.e_coverage_threshold is None:

            logger.info("It seems you haven't added empirical coverage info - new file is generating")
            genome_records = [seq for seq in (SeqIO.parse(self.database,"fasta"))]

            record_index = 1
            number_of_sequences = len(genome_records)

            with open("metaplasthunter_empirical_thresholds.txt","w") as f:

                while len(genome_records) > 0:
                    logger.info("Doing job: %s/%s" % (str(record_index),str(number_of_sequences)))
                    record_index = record_index + 1
                    record = genome_records.pop(0)
                    old_rec = record.id
                    if "|" in record.id:
                        record.id = (record.id).replace("|","_")
                    SeqIO.write(record,record.id+".fa","fasta")
                    threshold = self.run_MetaPlastHunter(record.id)
                    f.write("%s\t%s\n" % (old_rec, threshold))

            logger.info("Now you can add file called metaplasthunter_empirical_thresholds.txt to the settings")

        elif len(self.analyze_emp_genome_list()) > 1:

            genome_records = self.analyze_emp_genome_list()

            record_index = 1
            number_of_sequences = len(genome_records)
            logger.info("It seems that reference database has been updated - new empirical thresholds are generating")

            while len(genome_records) > 0:
                with open(self.e_coverage_threshold,"a") as f:
                    logger.info("Doing job: %s/%s" % (str(record_index), str(number_of_sequences)))
                    record_index = record_index + 1
                    record = genome_records.pop(0)
                    old_rec = record.id
                    if "|" in record.id:
                        record.id = (record.id).replace("|","_")
                    SeqIO.write(record,record.id+".fa","fasta")
                    threshold = self.run_MetaPlastHunter(record.id)
                    f.write("%s\t%s\n" % (old_rec, threshold))
        else:
            logger.info("Empiricial threshold file has been added correctly")